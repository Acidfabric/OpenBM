GAS LISTING /tmp/ccVHCL1a.s 			page 1


   1               		.file	"uart.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.stabs	"/media/sda6/home/tevs/src/psyBMW_trunk/avr/BordMonitor/",100,0,2,.Ltext0
  11               		.stabs	"uart.c",100,0,2,.Ltext0
  12               		.text
  13               	.Ltext0:
  14               		.stabs	"gcc2_compiled.",60,0,0,0
  15               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,1,0
  16               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,1,0
  17               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,1,0
  18               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,1,0
  19               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,1,0
  20               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,1,
  21               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,1,0
  22               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,1,0
  23               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,1,0
  24               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,1,0
  25               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,1,0
  26               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,1,0
  27               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,1,0
  28               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,1,0
  29               		.stabs	"void:t(0,15)=(0,15)",128,0,1,0
  30               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h",130,0,0,0
  31               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/sfr_defs.h",130,0,0,0
  32               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/inttypes.h",130,0,0,0
  33               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/stdint.h",130,0,0,0
  34               		.stabs	"int8_t:t(4,1)=(0,10)",128,0,121,0
  35               		.stabs	"uint8_t:t(4,2)=(0,11)",128,0,122,0
  36               		.stabs	"int16_t:t(4,3)=(0,1)",128,0,123,0
  37               		.stabs	"uint16_t:t(4,4)=(0,4)",128,0,124,0
  38               		.stabs	"int32_t:t(4,5)=(0,3)",128,0,125,0
  39               		.stabs	"uint32_t:t(4,6)=(0,5)",128,0,126,0
  40               		.stabs	"int64_t:t(4,7)=(0,6)",128,0,128,0
  41               		.stabs	"uint64_t:t(4,8)=(0,7)",128,0,129,0
  42               		.stabs	"intptr_t:t(4,9)=(4,3)",128,0,142,0
  43               		.stabs	"uintptr_t:t(4,10)=(4,4)",128,0,147,0
  44               		.stabs	"int_least8_t:t(4,11)=(4,1)",128,0,159,0
  45               		.stabs	"uint_least8_t:t(4,12)=(4,2)",128,0,164,0
  46               		.stabs	"int_least16_t:t(4,13)=(4,3)",128,0,169,0
  47               		.stabs	"uint_least16_t:t(4,14)=(4,4)",128,0,174,0
  48               		.stabs	"int_least32_t:t(4,15)=(4,5)",128,0,179,0
  49               		.stabs	"uint_least32_t:t(4,16)=(4,6)",128,0,184,0
  50               		.stabs	"int_least64_t:t(4,17)=(4,7)",128,0,192,0
  51               		.stabs	"uint_least64_t:t(4,18)=(4,8)",128,0,199,0
  52               		.stabs	"int_fast8_t:t(4,19)=(4,1)",128,0,213,0
  53               		.stabs	"uint_fast8_t:t(4,20)=(4,2)",128,0,218,0
  54               		.stabs	"int_fast16_t:t(4,21)=(4,3)",128,0,223,0
  55               		.stabs	"uint_fast16_t:t(4,22)=(4,4)",128,0,228,0
  56               		.stabs	"int_fast32_t:t(4,23)=(4,5)",128,0,233,0
  57               		.stabs	"uint_fast32_t:t(4,24)=(4,6)",128,0,238,0
GAS LISTING /tmp/ccVHCL1a.s 			page 2


  58               		.stabs	"int_fast64_t:t(4,25)=(4,7)",128,0,246,0
  59               		.stabs	"uint_fast64_t:t(4,26)=(4,8)",128,0,253,0
  60               		.stabs	"intmax_t:t(4,27)=(4,7)",128,0,273,0
  61               		.stabs	"uintmax_t:t(4,28)=(4,8)",128,0,278,0
  62               		.stabn	162,0,0,0
  63               		.stabs	"int_farptr_t:t(3,1)=(4,5)",128,0,77,0
  64               		.stabs	"uint_farptr_t:t(3,2)=(4,6)",128,0,81,0
  65               		.stabn	162,0,0,0
  66               		.stabn	162,0,0,0
  67               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/fuse.h",130,0,0,0
  68               		.stabs	"__fuse_t:t(5,1)=(5,2)=s2low:(0,11),0,8;high:(0,11),8,8;;",128,0,247,0
  69               		.stabn	162,0,0,0
  70               		.stabn	162,0,0,0
  71               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/pgmspace.h",130,0,0,0
  72               		.stabs	"/usr/lib/gcc/avr/4.3.4/include/stddef.h",130,0,0,0
  73               		.stabs	"size_t:t(7,1)=(0,4)",128,0,214,0
  74               		.stabn	162,0,0,0
  75               		.stabs	"prog_void:t(6,1)=(6,2)=(6,2)",128,0,211,0
  76               		.stabs	"prog_char:t(6,3)=(6,4)=@s8;r(6,4);0;255;",128,0,212,0
  77               		.stabs	"prog_uchar:t(6,5)=(6,4)",128,0,213,0
  78               		.stabs	"prog_int8_t:t(6,6)=(6,7)=(0,10)",128,0,215,0
  79               		.stabs	"prog_uint8_t:t(6,8)=(6,4)",128,0,216,0
  80               		.stabs	"prog_int16_t:t(6,9)=(6,10)=(0,1)",128,0,217,0
  81               		.stabs	"prog_uint16_t:t(6,11)=(6,12)=(0,4)",128,0,218,0
  82               		.stabs	"prog_int32_t:t(6,13)=(6,14)=(0,3)",128,0,219,0
  83               		.stabs	"prog_uint32_t:t(6,15)=(6,16)=(0,5)",128,0,220,0
  84               		.stabs	"prog_int64_t:t(6,17)=(6,18)=(0,6)",128,0,222,0
  85               		.stabs	"prog_uint64_t:t(6,19)=(6,20)=(0,7)",128,0,223,0
  86               		.stabn	162,0,0,0
  87               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/stdlib.h",130,0,0,0
  88               		.stabs	"/usr/lib/gcc/avr/4.3.4/include/stddef.h",130,0,0,0
  89               		.stabs	"wchar_t:t(9,1)=(0,1)",128,0,326,0
  90               		.stabn	162,0,0,0
  91               		.stabs	"div_t:t(8,1)=(8,2)=s4quot:(0,1),0,16;rem:(0,1),16,16;;",128,0,71,0
  92               		.stabs	"ldiv_t:t(8,3)=(8,4)=s8quot:(0,3),0,32;rem:(0,3),32,32;;",128,0,77,0
  93               		.stabs	"__compar_fn_t:t(8,5)=(8,6)=*(8,7)=f(0,1)",128,0,80,0
  94               		.stabn	162,0,0,0
  95               		.stabs	"__vector_13:F(0,15)",36,0,326,__vector_13
  96               	.global	__vector_13
  97               		.type	__vector_13, @function
  98               	__vector_13:
  99               		.stabd	46,0,0
   0:uart.c        **** /*************************************************************************
   1:uart.c        **** Title:    Interrupt UART library with receive/transmit circular buffers
   2:uart.c        **** Author:   Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   3:uart.c        **** File:     $Id: uart.c,v 1.6.2.1 2007/07/01 11:14:38 peter Exp $
   4:uart.c        **** Software: AVR-GCC 4.1, AVR Libc 1.4.6 or higher
   5:uart.c        **** Hardware: any AVR with built-in UART, 
   6:uart.c        **** License:  GNU General Public License 
   7:uart.c        ****           
   8:uart.c        **** DESCRIPTION:
   9:uart.c        ****     An interrupt is generated when the UART has finished transmitting or
  10:uart.c        ****     receiving a byte. The interrupt handling routines use circular buffers
  11:uart.c        ****     for buffering received and transmitted data.
  12:uart.c        ****     
  13:uart.c        ****     The UART_RX_BUFFER_SIZE and UART_TX_BUFFER_SIZE variables define
  14:uart.c        ****     the buffer size in bytes. Note that these variables must be a 
GAS LISTING /tmp/ccVHCL1a.s 			page 3


  15:uart.c        ****     power of 2.
  16:uart.c        ****     
  17:uart.c        **** USAGE:
  18:uart.c        ****     Refere to the header file uart.h for a description of the routines. 
  19:uart.c        ****     See also example test_uart.c.
  20:uart.c        **** 
  21:uart.c        **** NOTES:
  22:uart.c        ****     Based on Atmel Application Note AVR306
  23:uart.c        ****                     
  24:uart.c        **** LICENSE:
  25:uart.c        ****     Copyright (C) 2006 Peter Fleury
  26:uart.c        **** 
  27:uart.c        ****     This program is free software; you can redistribute it and/or modify
  28:uart.c        ****     it under the terms of the GNU General Public License as published by
  29:uart.c        ****     the Free Software Foundation; either version 2 of the License, or
  30:uart.c        ****     any later version.
  31:uart.c        **** 
  32:uart.c        ****     This program is distributed in the hope that it will be useful,
  33:uart.c        ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  34:uart.c        ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  35:uart.c        ****     GNU General Public License for more details.
  36:uart.c        ****                         
  37:uart.c        **** *************************************************************************/
  38:uart.c        **** 
  39:uart.c        **** /************************************************************************
  40:uart.c        **** uart_available, uart_flush, uart1_available, and uart1_flush functions
  41:uart.c        **** were adapted from the Arduino HardwareSerial.h library by Tim Sharpe on 
  42:uart.c        **** 11 Jan 2009.  The license info for HardwareSerial.h is as follows:
  43:uart.c        **** 
  44:uart.c        ****   HardwareSerial.cpp - Hardware serial library for Wiring
  45:uart.c        ****   Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
  46:uart.c        **** 
  47:uart.c        ****   This library is free software; you can redistribute it and/or
  48:uart.c        ****   modify it under the terms of the GNU Lesser General Public
  49:uart.c        ****   License as published by the Free Software Foundation; either
  50:uart.c        ****   version 2.1 of the License, or (at your option) any later version.
  51:uart.c        **** 
  52:uart.c        ****   This library is distributed in the hope that it will be useful,
  53:uart.c        ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  54:uart.c        ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  55:uart.c        ****   Lesser General Public License for more details.
  56:uart.c        **** 
  57:uart.c        ****   You should have received a copy of the GNU Lesser General Public
  58:uart.c        ****   License along with this library; if not, write to the Free Software
  59:uart.c        ****   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  60:uart.c        ****   
  61:uart.c        ****   Modified 23 November 2006 by David A. Mellis
  62:uart.c        **** ************************************************************************/
  63:uart.c        **** 
  64:uart.c        **** /************************************************************************
  65:uart.c        **** Changelog for modifications made by Tim Sharpe, starting with the current
  66:uart.c        ****   library version on his Web site as of 05/01/2009. 
  67:uart.c        **** 
  68:uart.c        **** Date        Description
  69:uart.c        **** =========================================================================
  70:uart.c        **** 05/11/2009  Changed all existing UARTx_RECEIVE_INTERRUPT and UARTx_TRANSMIT_INTERRUPT
  71:uart.c        ****               macros to use the "_vect" format introduced in AVR-Libc
GAS LISTING /tmp/ccVHCL1a.s 			page 4


  72:uart.c        **** 			  v1.4.0.  Had to split the 3290 and 6490 out of their existing
  73:uart.c        **** 			  macro due to an inconsistency in the UART0_RECEIVE_INTERRUPT 
  74:uart.c        **** 			  vector name (seems like a typo: USART_RX_vect for the 3290/6490
  75:uart.c        **** 			  vice USART0_RX_vect for the others in the macro).
  76:uart.c        **** 			Verified all existing macro register names against the device
  77:uart.c        **** 			  header files in AVR-Libc v1.6.6 to catch any inconsistencies.
  78:uart.c        **** 05/12/2009  Added support for 48P, 88P, 168P, and 328P by adding them to the
  79:uart.c        ****                existing 48/88/168 macro.
  80:uart.c        **** 			Added Arduino-style available() and flush() functions for both
  81:uart.c        **** 			supported UARTs.  Really wanted to keep them out of the library, so
  82:uart.c        **** 			that it would be as close as possible to Peter Fleury's original
  83:uart.c        **** 			library, but has scoping issues accessing internal variables from
  84:uart.c        **** 			another program.  Go C!
  85:uart.c        **** 05/13/2009  Changed Interrupt Service Routine label from the old "SIGNAL" to
  86:uart.c        ****                the "ISR" format introduced in AVR-Libc v1.4.0.
  87:uart.c        **** 
  88:uart.c        **** ************************************************************************/
  89:uart.c        **** 
  90:uart.c        **** #include <avr/io.h>
  91:uart.c        **** #include <avr/interrupt.h>
  92:uart.c        **** #include <avr/pgmspace.h>
  93:uart.c        **** #include "uart.h"
  94:uart.c        **** #include <inttypes.h>
  95:uart.c        **** #include <stdlib.h>
  96:uart.c        **** 
  97:uart.c        **** 
  98:uart.c        **** /*
  99:uart.c        ****  *  constants and macros
 100:uart.c        ****  */
 101:uart.c        **** 
 102:uart.c        **** /* size of RX/TX buffers */
 103:uart.c        **** #define UART_RX_BUFFER_MASK ( UART_RX_BUFFER_SIZE - 1)
 104:uart.c        **** #define UART_TX_BUFFER_MASK ( UART_TX_BUFFER_SIZE - 1)
 105:uart.c        **** 
 106:uart.c        **** #if ( UART_RX_BUFFER_SIZE & UART_RX_BUFFER_MASK )
 107:uart.c        **** #error RX buffer size is not a power of 2
 108:uart.c        **** #endif
 109:uart.c        **** #if ( UART_TX_BUFFER_SIZE & UART_TX_BUFFER_MASK )
 110:uart.c        **** #error TX buffer size is not a power of 2
 111:uart.c        **** #endif
 112:uart.c        **** 
 113:uart.c        **** #if defined(__AVR_AT90S2313__) \
 114:uart.c        ****  || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S4434__) \
 115:uart.c        ****  || defined(__AVR_AT90S8515__) || defined(__AVR_AT90S8535__) \
 116:uart.c        ****  || defined(__AVR_ATmega103__)
 117:uart.c        ****  /* old AVR classic or ATmega103 with one UART */
 118:uart.c        ****  #define AT90_UART
 119:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
 120:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 121:uart.c        ****  #define UART0_STATUS   USR
 122:uart.c        ****  #define UART0_CONTROL  UCR
 123:uart.c        ****  #define UART0_DATA     UDR  
 124:uart.c        ****  #define UART0_UDRIE    UDRIE
 125:uart.c        **** #elif defined(__AVR_AT90S2333__) || defined(__AVR_AT90S4433__)
 126:uart.c        ****  /* old AVR classic with one UART */
 127:uart.c        ****  #define AT90_UART
 128:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
GAS LISTING /tmp/ccVHCL1a.s 			page 5


 129:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 130:uart.c        ****  #define UART0_STATUS   UCSRA
 131:uart.c        ****  #define UART0_CONTROL  UCSRB
 132:uart.c        ****  #define UART0_DATA     UDR 
 133:uart.c        ****  #define UART0_UDRIE    UDRIE
 134:uart.c        **** #elif  defined(__AVR_ATmega8__)  || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 135:uart.c        ****   || defined(__AVR_ATmega323__)
 136:uart.c        ****   /* ATmega with one USART */
 137:uart.c        ****  #define ATMEGA_USART
 138:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RXC_vect
 139:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 140:uart.c        ****  #define UART0_STATUS   UCSRA
 141:uart.c        ****  #define UART0_CONTROL  UCSRB
 142:uart.c        ****  #define UART0_DATA     UDR
 143:uart.c        ****  #define UART0_UDRIE    UDRIE
 144:uart.c        **** #elif  defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 145:uart.c        ****   /* ATmega with one USART */
 146:uart.c        ****  #define ATMEGA_USART
 147:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 148:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 149:uart.c        ****  #define UART0_STATUS   UCSRA
 150:uart.c        ****  #define UART0_CONTROL  UCSRB
 151:uart.c        ****  #define UART0_DATA     UDR
 152:uart.c        ****  #define UART0_UDRIE    UDRIE
 153:uart.c        **** #elif defined(__AVR_ATmega163__) 
 154:uart.c        ****   /* ATmega163 with one UART */
 155:uart.c        ****  #define ATMEGA_UART
 156:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
 157:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 158:uart.c        ****  #define UART0_STATUS   UCSRA
 159:uart.c        ****  #define UART0_CONTROL  UCSRB
 160:uart.c        ****  #define UART0_DATA     UDR
 161:uart.c        ****  #define UART0_UDRIE    UDRIE
 162:uart.c        **** #elif defined(__AVR_ATmega162__) 
 163:uart.c        ****  /* ATmega with two USART */
 164:uart.c        ****  #define ATMEGA_USART0
 165:uart.c        ****  #define ATMEGA_USART1
 166:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RXC_vect
 167:uart.c        ****  #define UART1_RECEIVE_INTERRUPT   USART1_RXC_vect
 168:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 169:uart.c        ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 170:uart.c        ****  #define UART0_STATUS   UCSR0A
 171:uart.c        ****  #define UART0_CONTROL  UCSR0B
 172:uart.c        ****  #define UART0_DATA     UDR0
 173:uart.c        ****  #define UART0_UDRIE    UDRIE0
 174:uart.c        ****  #define UART1_STATUS   UCSR1A
 175:uart.c        ****  #define UART1_CONTROL  UCSR1B
 176:uart.c        ****  #define UART1_DATA     UDR1
 177:uart.c        ****  #define UART1_UDRIE    UDRIE1
 178:uart.c        **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) 
 179:uart.c        ****  /* ATmega with two USART */
 180:uart.c        ****  #define ATMEGA_USART0
 181:uart.c        ****  #define ATMEGA_USART1
 182:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 183:uart.c        ****  #define UART1_RECEIVE_INTERRUPT   USART1_RX_vect
 184:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 185:uart.c        ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
GAS LISTING /tmp/ccVHCL1a.s 			page 6


 186:uart.c        ****  #define UART0_STATUS   UCSR0A
 187:uart.c        ****  #define UART0_CONTROL  UCSR0B
 188:uart.c        ****  #define UART0_DATA     UDR0
 189:uart.c        ****  #define UART0_UDRIE    UDRIE0
 190:uart.c        ****  #define UART1_STATUS   UCSR1A
 191:uart.c        ****  #define UART1_CONTROL  UCSR1B
 192:uart.c        ****  #define UART1_DATA     UDR1
 193:uart.c        ****  #define UART1_UDRIE    UDRIE1
 194:uart.c        **** #elif defined(__AVR_ATmega161__)
 195:uart.c        ****  /* ATmega with UART */
 196:uart.c        ****  #error "AVR ATmega161 currently not supported by this libaray !"
 197:uart.c        **** #elif defined(__AVR_ATmega169__) 
 198:uart.c        ****  /* ATmega with one USART */
 199:uart.c        ****  #define ATMEGA_USART
 200:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 201:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 202:uart.c        ****  #define UART0_STATUS   UCSRA
 203:uart.c        ****  #define UART0_CONTROL  UCSRB
 204:uart.c        ****  #define UART0_DATA     UDR
 205:uart.c        ****  #define UART0_UDRIE    UDRIE
 206:uart.c        **** #elif defined(__AVR_ATmega48__) ||defined(__AVR_ATmega88__) || defined(__AVR_ATmega168__) || \
 207:uart.c        ****       defined(__AVR_ATmega48P__) ||defined(__AVR_ATmega88P__) || defined(__AVR_ATmega168P__) || \
 208:uart.c        ****       defined(__AVR_ATmega328P__) 
 209:uart.c        ****  /* TLS-Added 48P/88P/168P/328P */
 210:uart.c        ****  /* ATmega with one USART */
 211:uart.c        ****  #define ATMEGA_USART0
 212:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 213:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 214:uart.c        ****  #define UART0_STATUS   UCSR0A
 215:uart.c        ****  #define UART0_CONTROL  UCSR0B
 216:uart.c        ****  #define UART0_DATA     UDR0
 217:uart.c        ****  #define UART0_UDRIE    UDRIE0
 218:uart.c        **** #elif defined(__AVR_ATtiny2313__)
 219:uart.c        ****  #define ATMEGA_USART
 220:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect 
 221:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 222:uart.c        ****  #define UART0_STATUS   UCSRA
 223:uart.c        ****  #define UART0_CONTROL  UCSRB
 224:uart.c        ****  #define UART0_DATA     UDR
 225:uart.c        ****  #define UART0_UDRIE    UDRIE
 226:uart.c        **** #elif defined(__AVR_ATmega329__) ||\
 227:uart.c        ****       defined(__AVR_ATmega649__) ||\
 228:uart.c        ****       defined(__AVR_ATmega325__) ||defined(__AVR_ATmega3250__) ||\
 229:uart.c        ****       defined(__AVR_ATmega645__) ||defined(__AVR_ATmega6450__)
 230:uart.c        ****   /* ATmega with one USART */
 231:uart.c        ****   #define ATMEGA_USART0
 232:uart.c        ****   #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 233:uart.c        ****   #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 234:uart.c        ****   #define UART0_STATUS   UCSR0A
 235:uart.c        ****   #define UART0_CONTROL  UCSR0B
 236:uart.c        ****   #define UART0_DATA     UDR0
 237:uart.c        ****   #define UART0_UDRIE    UDRIE0
 238:uart.c        **** #elif defined(__AVR_ATmega3290__) ||\
 239:uart.c        ****       defined(__AVR_ATmega6490__) ||
 240:uart.c        ****   /* TLS-Separated these two from the previous group because of inconsistency in the USART_RX */
 241:uart.c        ****   /* ATmega with one USART */
 242:uart.c        ****   #define ATMEGA_USART0
GAS LISTING /tmp/ccVHCL1a.s 			page 7


 243:uart.c        ****   #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 244:uart.c        ****   #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 245:uart.c        ****   #define UART0_STATUS   UCSR0A
 246:uart.c        ****   #define UART0_CONTROL  UCSR0B
 247:uart.c        ****   #define UART0_DATA     UDR0
 248:uart.c        ****   #define UART0_UDRIE    UDRIE0
 249:uart.c        **** #elif defined(__AVR_ATmega2560__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega640__)
 250:uart.c        **** /* ATmega with two USART */
 251:uart.c        ****   #define ATMEGA_USART0
 252:uart.c        ****   #define ATMEGA_USART1
 253:uart.c        ****   #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 254:uart.c        ****   #define UART1_RECEIVE_INTERRUPT   USART0_UDRE_vect
 255:uart.c        ****   #define UART0_TRANSMIT_INTERRUPT  USART1_RX_vect
 256:uart.c        ****   #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 257:uart.c        ****   #define UART0_STATUS   UCSR0A
 258:uart.c        ****   #define UART0_CONTROL  UCSR0B
 259:uart.c        ****   #define UART0_DATA     UDR0
 260:uart.c        ****   #define UART0_UDRIE    UDRIE0
 261:uart.c        ****   #define UART1_STATUS   UCSR1A
 262:uart.c        ****   #define UART1_CONTROL  UCSR1B
 263:uart.c        ****   #define UART1_DATA     UDR1
 264:uart.c        ****   #define UART1_UDRIE    UDRIE1  
 265:uart.c        **** #elif defined(__AVR_ATmega644__)
 266:uart.c        ****  /* ATmega with one USART */
 267:uart.c        ****  #define ATMEGA_USART0
 268:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 269:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 270:uart.c        ****  #define UART0_STATUS   UCSR0A
 271:uart.c        ****  #define UART0_CONTROL  UCSR0B
 272:uart.c        ****  #define UART0_DATA     UDR0
 273:uart.c        ****  #define UART0_UDRIE    UDRIE0
 274:uart.c        **** #elif defined(__AVR_ATmega164P__) || defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__)
 275:uart.c        ****  /* ATmega with two USART */
 276:uart.c        ****  #define ATMEGA_USART0
 277:uart.c        ****  #define ATMEGA_USART1
 278:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 279:uart.c        ****  #define UART1_RECEIVE_INTERRUPT   USART0_UDRE_vect
 280:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART1_RX_vect
 281:uart.c        ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 282:uart.c        ****  #define UART0_STATUS   UCSR0A
 283:uart.c        ****  #define UART0_CONTROL  UCSR0B
 284:uart.c        ****  #define UART0_DATA     UDR0
 285:uart.c        ****  #define UART0_UDRIE    UDRIE0
 286:uart.c        ****  #define UART1_STATUS   UCSR1A
 287:uart.c        ****  #define UART1_CONTROL  UCSR1B
 288:uart.c        ****  #define UART1_DATA     UDR1
 289:uart.c        ****  #define UART1_UDRIE    UDRIE1
 290:uart.c        **** //#else
 291:uart.c        **** // #error "no UART definition for MCU available"
 292:uart.c        **** #endif
 293:uart.c        **** 
 294:uart.c        **** 
 295:uart.c        **** /*
 296:uart.c        ****  *  module global variables
 297:uart.c        ****  */
 298:uart.c        **** static volatile unsigned char UART_TxBuf[UART_TX_BUFFER_SIZE];
 299:uart.c        **** static volatile unsigned char UART_RxBuf[UART_RX_BUFFER_SIZE];
GAS LISTING /tmp/ccVHCL1a.s 			page 8


 300:uart.c        **** static volatile unsigned char UART_TxHead;
 301:uart.c        **** static volatile unsigned char UART_TxTail;
 302:uart.c        **** static volatile unsigned char UART_RxHead;
 303:uart.c        **** static volatile unsigned char UART_RxTail;
 304:uart.c        **** static volatile unsigned char UART_LastRxError;
 305:uart.c        **** static void (*UART_TransmittedCallback)(void);
 306:uart.c        **** static void (*UART_ReceivedCallback)(void);
 307:uart.c        **** 
 308:uart.c        **** #if defined( ATMEGA_USART1 )
 309:uart.c        **** static volatile unsigned char UART1_TxBuf[UART_TX_BUFFER_SIZE];
 310:uart.c        **** static volatile unsigned char UART1_RxBuf[UART_RX_BUFFER_SIZE];
 311:uart.c        **** static volatile unsigned char UART1_TxHead;
 312:uart.c        **** static volatile unsigned char UART1_TxTail;
 313:uart.c        **** static volatile unsigned char UART1_RxHead;
 314:uart.c        **** static volatile unsigned char UART1_RxTail;
 315:uart.c        **** static volatile unsigned char UART1_LastRxError;
 316:uart.c        **** #endif
 317:uart.c        **** 
 318:uart.c        **** 
 319:uart.c        **** 
 320:uart.c        **** ISR(UART0_RECEIVE_INTERRUPT)
 321:uart.c        **** /*************************************************************************
 322:uart.c        **** Function: UART Receive Complete interrupt
 323:uart.c        **** Purpose:  called when the UART has received a character
 324:uart.c        **** **************************************************************************/
 325:uart.c        **** {
 100               		.stabn	68,0,326,.LM0-.LFBB1
 101               	.LM0:
 102               	.LFBB1:
 103 0000 1F92      		push __zero_reg__
 104 0002 0F92      		push r0
 105 0004 0FB6      		in r0,__SREG__
 106 0006 0F92      		push r0
 107 0008 1124      		clr __zero_reg__
 108 000a 2F93      		push r18
 109 000c 3F93      		push r19
 110 000e 4F93      		push r20
 111 0010 5F93      		push r21
 112 0012 6F93      		push r22
 113 0014 7F93      		push r23
 114 0016 8F93      		push r24
 115 0018 9F93      		push r25
 116 001a AF93      		push r26
 117 001c BF93      		push r27
 118 001e EF93      		push r30
 119 0020 FF93      		push r31
 120               	/* prologue: Signal */
 121               	/* frame size = 0 */
 326:uart.c        ****     unsigned char tmphead;
 327:uart.c        ****     unsigned char data;
 328:uart.c        ****     unsigned char usr;
 329:uart.c        ****     unsigned char lastRxError;
 330:uart.c        ****  
 331:uart.c        ****  
 332:uart.c        ****     /* read UART status register and UART data register */ 
 333:uart.c        ****     usr  = UART0_STATUS;
 122               		.stabn	68,0,334,.LM1-.LFBB1
GAS LISTING /tmp/ccVHCL1a.s 			page 9


 123               	.LM1:
 124 0022 9BB1      		in r25,43-32
 334:uart.c        ****     data = UART0_DATA;
 125               		.stabn	68,0,335,.LM2-.LFBB1
 126               	.LM2:
 127 0024 2CB1      		in r18,44-32
 335:uart.c        ****     
 336:uart.c        ****     /* */
 337:uart.c        **** #if defined( AT90_UART )
 338:uart.c        ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)|_BV(PE)) );
 339:uart.c        **** #elif defined( ATMEGA_USART )
 340:uart.c        ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)|_BV(PE)) );
 341:uart.c        **** #elif defined( ATMEGA_USART0 )
 342:uart.c        ****     lastRxError = (usr & (_BV(FE0)|_BV(DOR0)|_BV(PE)) );
 343:uart.c        **** #elif defined ( ATMEGA_UART )
 344:uart.c        ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)|_BV(PE)) );
 345:uart.c        **** #endif
 346:uart.c        ****         
 347:uart.c        ****     /* calculate buffer index */ 
 348:uart.c        ****     tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
 128               		.stabn	68,0,349,.LM3-.LFBB1
 129               	.LM3:
 130 0026 E091 0000 		lds r30,UART_RxHead
 131 002a EF5F      		subi r30,lo8(-(1))
 132 002c EF70      		andi r30,lo8(15)
 349:uart.c        ****     
 350:uart.c        ****     if ( tmphead == UART_RxTail ) {
 133               		.stabn	68,0,351,.LM4-.LFBB1
 134               	.LM4:
 135 002e 8091 0000 		lds r24,UART_RxTail
 136 0032 E817      		cp r30,r24
 137 0034 01F4      		brne .L2
 138 0036 82E0      		ldi r24,lo8(2)
 139 0038 00C0      		rjmp .L3
 140               	.L2:
 341:uart.c        ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)|_BV(PE)) );
 141               		.stabn	68,0,341,.LM5-.LFBB1
 142               	.LM5:
 143 003a 892F      		mov r24,r25
 144 003c 8C71      		andi r24,lo8(28)
 351:uart.c        ****         /* error: receive buffer overflow */
 352:uart.c        ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 353:uart.c        ****     }else{
 354:uart.c        ****         /* store new index */
 355:uart.c        ****         UART_RxHead = tmphead;
 145               		.stabn	68,0,356,.LM6-.LFBB1
 146               	.LM6:
 147 003e E093 0000 		sts UART_RxHead,r30
 356:uart.c        ****         /* store received data in buffer */
 357:uart.c        ****         UART_RxBuf[tmphead] = data;
 148               		.stabn	68,0,358,.LM7-.LFBB1
 149               	.LM7:
 150 0042 F0E0      		ldi r31,lo8(0)
 151 0044 E050      		subi r30,lo8(-(UART_RxBuf))
 152 0046 F040      		sbci r31,hi8(-(UART_RxBuf))
 153 0048 2083      		st Z,r18
 154               	.L3:
GAS LISTING /tmp/ccVHCL1a.s 			page 10


 358:uart.c        ****     }
 359:uart.c        ****     UART_LastRxError = lastRxError;
 155               		.stabn	68,0,360,.LM8-.LFBB1
 156               	.LM8:
 157 004a 8093 0000 		sts UART_LastRxError,r24
 360:uart.c        **** 
 361:uart.c        ****     if (UART_ReceivedCallback)
 158               		.stabn	68,0,362,.LM9-.LFBB1
 159               	.LM9:
 160 004e E091 0000 		lds r30,UART_ReceivedCallback
 161 0052 F091 0000 		lds r31,(UART_ReceivedCallback)+1
 162 0056 3097      		sbiw r30,0
 163 0058 01F0      		breq .L5
 362:uart.c        ****         UART_ReceivedCallback();
 164               		.stabn	68,0,363,.LM10-.LFBB1
 165               	.LM10:
 166 005a 0995      		icall
 167               	.L5:
 168               	/* epilogue start */
 363:uart.c        **** }
 169               		.stabn	68,0,364,.LM11-.LFBB1
 170               	.LM11:
 171 005c FF91      		pop r31
 172 005e EF91      		pop r30
 173 0060 BF91      		pop r27
 174 0062 AF91      		pop r26
 175 0064 9F91      		pop r25
 176 0066 8F91      		pop r24
 177 0068 7F91      		pop r23
 178 006a 6F91      		pop r22
 179 006c 5F91      		pop r21
 180 006e 4F91      		pop r20
 181 0070 3F91      		pop r19
 182 0072 2F91      		pop r18
 183 0074 0F90      		pop r0
 184 0076 0FBE      		out __SREG__,r0
 185 0078 0F90      		pop r0
 186 007a 1F90      		pop __zero_reg__
 187 007c 1895      		reti
 188               		.size	__vector_13, .-__vector_13
 189               		.stabs	"tmphead:r(0,11)",64,0,327,30
 190               		.stabs	"data:r(0,11)",64,0,328,18
 191               		.stabs	"usr:r(0,11)",64,0,329,25
 192               		.stabs	"lastRxError:r(0,11)",64,0,330,24
 193               		.stabn	192,0,0,.LFBB1-.LFBB1
 194               		.stabn	224,0,0,.Lscope1-.LFBB1
 195               	.Lscope1:
 196               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 197               		.stabd	78,0,0
 198               		.stabs	"__vector_14:F(0,15)",36,0,372,__vector_14
 199               	.global	__vector_14
 200               		.type	__vector_14, @function
 201               	__vector_14:
 202               		.stabd	46,0,0
 364:uart.c        **** 
 365:uart.c        **** 
 366:uart.c        **** ISR(UART0_TRANSMIT_INTERRUPT)
GAS LISTING /tmp/ccVHCL1a.s 			page 11


 367:uart.c        **** /*************************************************************************
 368:uart.c        **** Function: UART Data Register Empty interrupt
 369:uart.c        **** Purpose:  called when the UART is ready to transmit the next byte
 370:uart.c        **** **************************************************************************/
 371:uart.c        **** {
 203               		.stabn	68,0,372,.LM12-.LFBB2
 204               	.LM12:
 205               	.LFBB2:
 206 007e 1F92      		push __zero_reg__
 207 0080 0F92      		push r0
 208 0082 0FB6      		in r0,__SREG__
 209 0084 0F92      		push r0
 210 0086 1124      		clr __zero_reg__
 211 0088 2F93      		push r18
 212 008a 3F93      		push r19
 213 008c 4F93      		push r20
 214 008e 5F93      		push r21
 215 0090 6F93      		push r22
 216 0092 7F93      		push r23
 217 0094 8F93      		push r24
 218 0096 9F93      		push r25
 219 0098 AF93      		push r26
 220 009a BF93      		push r27
 221 009c EF93      		push r30
 222 009e FF93      		push r31
 223               	/* prologue: Signal */
 224               	/* frame size = 0 */
 372:uart.c        ****     unsigned char tmptail;
 373:uart.c        **** 
 374:uart.c        ****     if ( UART_TxHead != UART_TxTail) {
 225               		.stabn	68,0,375,.LM13-.LFBB2
 226               	.LM13:
 227 00a0 9091 0000 		lds r25,UART_TxHead
 228 00a4 8091 0000 		lds r24,UART_TxTail
 229 00a8 9817      		cp r25,r24
 230 00aa 01F0      		breq .L7
 375:uart.c        ****         /* calculate and store new buffer index */
 376:uart.c        ****         tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 231               		.stabn	68,0,377,.LM14-.LFBB2
 232               	.LM14:
 233 00ac E091 0000 		lds r30,UART_TxTail
 234 00b0 EF5F      		subi r30,lo8(-(1))
 377:uart.c        ****         UART_TxTail = tmptail;
 235               		.stabn	68,0,378,.LM15-.LFBB2
 236               	.LM15:
 237 00b2 E093 0000 		sts UART_TxTail,r30
 378:uart.c        ****         /* get one byte from buffer and write it to UART */
 379:uart.c        ****         UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 238               		.stabn	68,0,380,.LM16-.LFBB2
 239               	.LM16:
 240 00b6 F0E0      		ldi r31,lo8(0)
 241 00b8 E050      		subi r30,lo8(-(UART_TxBuf))
 242 00ba F040      		sbci r31,hi8(-(UART_TxBuf))
 243 00bc 8081      		ld r24,Z
 244 00be 8CB9      		out 44-32,r24
 245 00c0 00C0      		rjmp .L9
 246               	.L7:
GAS LISTING /tmp/ccVHCL1a.s 			page 12


 380:uart.c        ****     }else{
 381:uart.c        ****         /* tx buffer empty, disable UDRE interrupt */
 382:uart.c        ****         UART0_CONTROL &= ~_BV(UART0_UDRIE);
 247               		.stabn	68,0,383,.LM17-.LFBB2
 248               	.LM17:
 249 00c2 5598      		cbi 42-32,5
 383:uart.c        **** 
 384:uart.c        ****         /* callback if set */
 385:uart.c        ****         if (UART_TransmittedCallback)
 250               		.stabn	68,0,386,.LM18-.LFBB2
 251               	.LM18:
 252 00c4 E091 0000 		lds r30,UART_TransmittedCallback
 253 00c8 F091 0000 		lds r31,(UART_TransmittedCallback)+1
 254 00cc 3097      		sbiw r30,0
 255 00ce 01F0      		breq .L9
 386:uart.c        ****             UART_TransmittedCallback();
 256               		.stabn	68,0,387,.LM19-.LFBB2
 257               	.LM19:
 258 00d0 0995      		icall
 259               	.L9:
 260               	/* epilogue start */
 387:uart.c        ****     }
 388:uart.c        **** }
 261               		.stabn	68,0,389,.LM20-.LFBB2
 262               	.LM20:
 263 00d2 FF91      		pop r31
 264 00d4 EF91      		pop r30
 265 00d6 BF91      		pop r27
 266 00d8 AF91      		pop r26
 267 00da 9F91      		pop r25
 268 00dc 8F91      		pop r24
 269 00de 7F91      		pop r23
 270 00e0 6F91      		pop r22
 271 00e2 5F91      		pop r21
 272 00e4 4F91      		pop r20
 273 00e6 3F91      		pop r19
 274 00e8 2F91      		pop r18
 275 00ea 0F90      		pop r0
 276 00ec 0FBE      		out __SREG__,r0
 277 00ee 0F90      		pop r0
 278 00f0 1F90      		pop __zero_reg__
 279 00f2 1895      		reti
 280               		.size	__vector_14, .-__vector_14
 281               		.stabs	"tmptail:r(0,11)",64,0,373,30
 282               		.stabn	192,0,0,.LFBB2-.LFBB2
 283               		.stabn	224,0,0,.Lscope2-.LFBB2
 284               	.Lscope2:
 285               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 286               		.stabd	78,0,0
 287               		.stabs	"uart_init:F(0,15)",36,0,399,uart_init
 288               		.stabs	"baudrate:P(0,4)",64,0,398,18
 289               	.global	uart_init
 290               		.type	uart_init, @function
 291               	uart_init:
 292               		.stabd	46,0,0
 389:uart.c        **** 
 390:uart.c        **** 
GAS LISTING /tmp/ccVHCL1a.s 			page 13


 391:uart.c        **** /*************************************************************************
 392:uart.c        **** Function: uart_init()
 393:uart.c        **** Purpose:  initialize UART and set baudrate
 394:uart.c        **** Input:    baudrate using macro UART_BAUD_SELECT()
 395:uart.c        **** Returns:  none
 396:uart.c        **** **************************************************************************/
 397:uart.c        **** void uart_init(unsigned int baudrate)
 398:uart.c        **** {
 293               		.stabn	68,0,399,.LM21-.LFBB3
 294               	.LM21:
 295               	.LFBB3:
 296               	/* prologue: function */
 297               	/* frame size = 0 */
 298 00f4 9C01      		movw r18,r24
 399:uart.c        ****     UART_TxHead = 0;
 299               		.stabn	68,0,400,.LM22-.LFBB3
 300               	.LM22:
 301 00f6 1092 0000 		sts UART_TxHead,__zero_reg__
 400:uart.c        ****     UART_TxTail = 0;
 302               		.stabn	68,0,401,.LM23-.LFBB3
 303               	.LM23:
 304 00fa 1092 0000 		sts UART_TxTail,__zero_reg__
 401:uart.c        ****     UART_RxHead = 0;
 305               		.stabn	68,0,402,.LM24-.LFBB3
 306               	.LM24:
 307 00fe 1092 0000 		sts UART_RxHead,__zero_reg__
 402:uart.c        ****     UART_RxTail = 0;
 308               		.stabn	68,0,403,.LM25-.LFBB3
 309               	.LM25:
 310 0102 1092 0000 		sts UART_RxTail,__zero_reg__
 403:uart.c        ****     UART_TransmittedCallback = NULL;
 311               		.stabn	68,0,404,.LM26-.LFBB3
 312               	.LM26:
 313 0106 1092 0000 		sts (UART_TransmittedCallback)+1,__zero_reg__
 314 010a 1092 0000 		sts UART_TransmittedCallback,__zero_reg__
 404:uart.c        ****     UART_ReceivedCallback = NULL;
 315               		.stabn	68,0,405,.LM27-.LFBB3
 316               	.LM27:
 317 010e 1092 0000 		sts (UART_ReceivedCallback)+1,__zero_reg__
 318 0112 1092 0000 		sts UART_ReceivedCallback,__zero_reg__
 405:uart.c        **** 
 406:uart.c        **** #if defined( AT90_UART )
 407:uart.c        ****     /* set baud rate */
 408:uart.c        ****     UBRR = (unsigned char)baudrate; 
 409:uart.c        **** 
 410:uart.c        ****     /* enable UART receiver and transmmitter and receive complete interrupt */
 411:uart.c        ****     UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);
 412:uart.c        **** 
 413:uart.c        **** #elif defined (ATMEGA_USART)
 414:uart.c        ****     /* Set baud rate */
 415:uart.c        ****     if ( baudrate & 0x8000 )
 319               		.stabn	68,0,416,.LM28-.LFBB3
 320               	.LM28:
 321 0116 97FF      		sbrs r25,7
 322 0118 00C0      		rjmp .L11
 416:uart.c        ****     {
 417:uart.c        ****     	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
GAS LISTING /tmp/ccVHCL1a.s 			page 14


 323               		.stabn	68,0,418,.LM29-.LFBB3
 324               	.LM29:
 325 011a 82E0      		ldi r24,lo8(2)
 326 011c 8BB9      		out 43-32,r24
 418:uart.c        ****     	 baudrate &= ~0x8000;
 327               		.stabn	68,0,419,.LM30-.LFBB3
 328               	.LM30:
 329 011e 3F77      		andi r19,hi8(32767)
 330               	.L11:
 419:uart.c        ****     }
 420:uart.c        ****     UBRRH = (unsigned char)(baudrate>>8);
 331               		.stabn	68,0,421,.LM31-.LFBB3
 332               	.LM31:
 333 0120 30BD      		out 64-32,r19
 421:uart.c        ****     UBRRL = (unsigned char) baudrate;
 334               		.stabn	68,0,422,.LM32-.LFBB3
 335               	.LM32:
 336 0122 29B9      		out 41-32,r18
 422:uart.c        ****    
 423:uart.c        ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 424:uart.c        ****     UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 337               		.stabn	68,0,425,.LM33-.LFBB3
 338               	.LM33:
 339 0124 88E9      		ldi r24,lo8(-104)
 340 0126 8AB9      		out 42-32,r24
 425:uart.c        ****     
 426:uart.c        ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 427:uart.c        ****     #ifdef URSEL
 428:uart.c        ****     UCSRC = (1<<URSEL)|(3<<UCSZ0);
 341               		.stabn	68,0,429,.LM34-.LFBB3
 342               	.LM34:
 343 0128 86E8      		ldi r24,lo8(-122)
 344 012a 80BD      		out 64-32,r24
 345               	/* epilogue start */
 429:uart.c        ****     #else
 430:uart.c        ****     UCSRC = (3<<UCSZ0);
 431:uart.c        ****     #endif 
 432:uart.c        ****     
 433:uart.c        **** #elif defined (ATMEGA_USART0 )
 434:uart.c        ****     /* Set baud rate */
 435:uart.c        ****     if ( baudrate & 0x8000 ) 
 436:uart.c        ****     {
 437:uart.c        ****    		UART0_STATUS = (1<<U2X0);  //Enable 2x speed 
 438:uart.c        ****    		baudrate &= ~0x8000;
 439:uart.c        ****    	}
 440:uart.c        ****     UBRR0H = (unsigned char)(baudrate>>8);
 441:uart.c        ****     UBRR0L = (unsigned char) baudrate;
 442:uart.c        **** 
 443:uart.c        ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 444:uart.c        ****     UART0_CONTROL = _BV(RXCIE0)|(1<<RXEN0)|(1<<TXEN0);
 445:uart.c        ****     
 446:uart.c        ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 447:uart.c        ****     #ifdef URSEL0
 448:uart.c        ****     UCSR0C = (1<<URSEL0)|(3<<UCSZ00);
 449:uart.c        ****     #else
 450:uart.c        ****     UCSR0C = (3<<UCSZ00);
 451:uart.c        ****     #endif 
GAS LISTING /tmp/ccVHCL1a.s 			page 15


 452:uart.c        **** 
 453:uart.c        **** #elif defined ( ATMEGA_UART )
 454:uart.c        ****     /* set baud rate */
 455:uart.c        ****     if ( baudrate & 0x8000 ) 
 456:uart.c        ****     {
 457:uart.c        ****     	UART0_STATUS = (1<<U2X);  //Enable 2x speed 
 458:uart.c        ****     	baudrate &= ~0x8000;
 459:uart.c        ****     }
 460:uart.c        ****     UBRRHI = (unsigned char)(baudrate>>8);
 461:uart.c        ****     UBRR   = (unsigned char) baudrate;
 462:uart.c        **** 
 463:uart.c        ****     /* Enable UART receiver and transmitter and receive complete interrupt */
 464:uart.c        ****     UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 465:uart.c        **** 
 466:uart.c        **** #endif
 467:uart.c        **** 
 468:uart.c        **** }/* uart_init */
 346               		.stabn	68,0,469,.LM35-.LFBB3
 347               	.LM35:
 348 012c 0895      		ret
 349               		.size	uart_init, .-uart_init
 350               	.Lscope3:
 351               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 352               		.stabd	78,0,0
 353               		.stabs	"uart_getc:F(0,4)",36,0,479,uart_getc
 354               	.global	uart_getc
 355               		.type	uart_getc, @function
 356               	uart_getc:
 357               		.stabd	46,0,0
 469:uart.c        **** 
 470:uart.c        **** 
 471:uart.c        **** /*************************************************************************
 472:uart.c        **** Function: uart_getc()
 473:uart.c        **** Purpose:  return byte from ringbuffer  
 474:uart.c        **** Returns:  lower byte:  received byte from ringbuffer
 475:uart.c        ****           higher byte: last receive error
 476:uart.c        **** **************************************************************************/
 477:uart.c        **** unsigned int uart_getc(void)
 478:uart.c        **** {    
 358               		.stabn	68,0,479,.LM36-.LFBB4
 359               	.LM36:
 360               	.LFBB4:
 361               	/* prologue: function */
 362               	/* frame size = 0 */
 479:uart.c        ****     unsigned char tmptail;
 480:uart.c        ****     unsigned char data;
 481:uart.c        **** 
 482:uart.c        **** 
 483:uart.c        ****     if ( UART_RxHead == UART_RxTail ) {
 363               		.stabn	68,0,484,.LM37-.LFBB4
 364               	.LM37:
 365 012e 9091 0000 		lds r25,UART_RxHead
 366 0132 8091 0000 		lds r24,UART_RxTail
 367 0136 9817      		cp r25,r24
 368 0138 01F4      		brne .L14
 369 013a 20E0      		ldi r18,lo8(256)
 370 013c 31E0      		ldi r19,hi8(256)
GAS LISTING /tmp/ccVHCL1a.s 			page 16


 371 013e 00C0      		rjmp .L15
 372               	.L14:
 484:uart.c        ****         return UART_NO_DATA;   /* no data available */
 485:uart.c        ****     }
 486:uart.c        ****     
 487:uart.c        ****     /* calculate /store buffer index */
 488:uart.c        ****     tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 373               		.stabn	68,0,489,.LM38-.LFBB4
 374               	.LM38:
 375 0140 E091 0000 		lds r30,UART_RxTail
 376 0144 EF5F      		subi r30,lo8(-(1))
 377 0146 EF70      		andi r30,lo8(15)
 489:uart.c        ****     UART_RxTail = tmptail; 
 378               		.stabn	68,0,490,.LM39-.LFBB4
 379               	.LM39:
 380 0148 E093 0000 		sts UART_RxTail,r30
 490:uart.c        ****     
 491:uart.c        ****     /* get data from receive buffer */
 492:uart.c        ****     data = UART_RxBuf[tmptail];
 381               		.stabn	68,0,493,.LM40-.LFBB4
 382               	.LM40:
 383 014c F0E0      		ldi r31,lo8(0)
 384 014e E050      		subi r30,lo8(-(UART_RxBuf))
 385 0150 F040      		sbci r31,hi8(-(UART_RxBuf))
 386 0152 3081      		ld r19,Z
 493:uart.c        ****     
 494:uart.c        ****     return (UART_LastRxError << 8) + data;
 387               		.stabn	68,0,495,.LM41-.LFBB4
 388               	.LM41:
 389 0154 2091 0000 		lds r18,UART_LastRxError
 390 0158 922F      		mov r25,r18
 391 015a 80E0      		ldi r24,lo8(0)
 392 015c AC01      		movw r20,r24
 393 015e 430F      		add r20,r19
 394 0160 511D      		adc r21,__zero_reg__
 395 0162 9A01      		movw r18,r20
 396               	.L15:
 495:uart.c        **** 
 496:uart.c        **** }/* uart_getc */
 397               		.stabn	68,0,497,.LM42-.LFBB4
 398               	.LM42:
 399 0164 C901      		movw r24,r18
 400               	/* epilogue start */
 401 0166 0895      		ret
 402               		.size	uart_getc, .-uart_getc
 403               		.stabs	"tmptail:r(0,11)",64,0,480,30
 404               		.stabs	"data:r(0,11)",64,0,481,19
 405               		.stabn	192,0,0,.LFBB4-.LFBB4
 406               		.stabn	224,0,0,.Lscope4-.LFBB4
 407               	.Lscope4:
 408               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 409               		.stabd	78,0,0
 410               		.stabs	"uart_putc:F(0,15)",36,0,507,uart_putc
 411               		.stabs	"data:P(0,11)",64,0,506,18
 412               		.stabs	"startDelayed:P(0,11)",64,0,506,22
 413               	.global	uart_putc
 414               		.type	uart_putc, @function
GAS LISTING /tmp/ccVHCL1a.s 			page 17


 415               	uart_putc:
 416               		.stabd	46,0,0
 497:uart.c        **** 
 498:uart.c        **** 
 499:uart.c        **** /*************************************************************************
 500:uart.c        **** Function: uart_putc()
 501:uart.c        **** Purpose:  write byte to ringbuffer for transmitting via UART
 502:uart.c        **** Input:    byte to be transmitted
 503:uart.c        **** Returns:  none          
 504:uart.c        **** **************************************************************************/
 505:uart.c        **** void uart_putc(unsigned char data, unsigned char startDelayed)
 506:uart.c        **** {
 417               		.stabn	68,0,507,.LM43-.LFBB5
 418               	.LM43:
 419               	.LFBB5:
 420               	/* prologue: function */
 421               	/* frame size = 0 */
 422 0168 282F      		mov r18,r24
 507:uart.c        ****     unsigned char tmphead;
 508:uart.c        **** 
 509:uart.c        ****     
 510:uart.c        ****     tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 423               		.stabn	68,0,511,.LM44-.LFBB5
 424               	.LM44:
 425 016a 9091 0000 		lds r25,UART_TxHead
 426 016e 9F5F      		subi r25,lo8(-(1))
 427               	.L18:
 511:uart.c        ****     
 512:uart.c        ****     while ( tmphead == UART_TxTail ){
 428               		.stabn	68,0,513,.LM45-.LFBB5
 429               	.LM45:
 430 0170 8091 0000 		lds r24,UART_TxTail
 431 0174 9817      		cp r25,r24
 432 0176 01F0      		breq .L18
 513:uart.c        ****         ;/* wait for free space in buffer */
 514:uart.c        ****     }
 515:uart.c        ****     
 516:uart.c        ****     UART_TxBuf[tmphead] = data;
 433               		.stabn	68,0,517,.LM46-.LFBB5
 434               	.LM46:
 435 0178 E92F      		mov r30,r25
 436 017a F0E0      		ldi r31,lo8(0)
 437 017c E050      		subi r30,lo8(-(UART_TxBuf))
 438 017e F040      		sbci r31,hi8(-(UART_TxBuf))
 439 0180 2083      		st Z,r18
 517:uart.c        ****     UART_TxHead = tmphead;
 440               		.stabn	68,0,518,.LM47-.LFBB5
 441               	.LM47:
 442 0182 9093 0000 		sts UART_TxHead,r25
 518:uart.c        **** 
 519:uart.c        ****     if (startDelayed) return;
 443               		.stabn	68,0,520,.LM48-.LFBB5
 444               	.LM48:
 445 0186 6623      		tst r22
 446 0188 01F4      		brne .L20
 520:uart.c        **** 
 521:uart.c        ****     /* enable UDRE interrupt */
GAS LISTING /tmp/ccVHCL1a.s 			page 18


 522:uart.c        ****     UART0_CONTROL    |= _BV(UART0_UDRIE);
 447               		.stabn	68,0,523,.LM49-.LFBB5
 448               	.LM49:
 449 018a 559A      		sbi 42-32,5
 450               	.L20:
 451 018c 0895      		ret
 452               		.size	uart_putc, .-uart_putc
 453               		.stabs	"tmphead:r(0,11)",64,0,508,25
 454               		.stabn	192,0,0,.LFBB5-.LFBB5
 455               		.stabn	224,0,0,.Lscope5-.LFBB5
 456               	.Lscope5:
 457               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 458               		.stabd	78,0,0
 459               		.stabs	"uart_startTransmission:F(0,15)",36,0,529,uart_startTransmission
 460               	.global	uart_startTransmission
 461               		.type	uart_startTransmission, @function
 462               	uart_startTransmission:
 463               		.stabd	46,0,0
 523:uart.c        **** 
 524:uart.c        **** }/* uart_putc */
 525:uart.c        **** 
 526:uart.c        **** 
 527:uart.c        **** void uart_startTransmission(void)
 528:uart.c        **** {
 464               		.stabn	68,0,529,.LM50-.LFBB6
 465               	.LM50:
 466               	.LFBB6:
 467               	/* prologue: function */
 468               	/* frame size = 0 */
 529:uart.c        ****     /* enable UDRE interrupt */
 530:uart.c        ****     UART0_CONTROL    |= _BV(UART0_UDRIE);
 469               		.stabn	68,0,531,.LM51-.LFBB6
 470               	.LM51:
 471 018e 559A      		sbi 42-32,5
 472               	/* epilogue start */
 531:uart.c        **** }
 473               		.stabn	68,0,532,.LM52-.LFBB6
 474               	.LM52:
 475 0190 0895      		ret
 476               		.size	uart_startTransmission, .-uart_startTransmission
 477               	.Lscope6:
 478               		.stabs	"",36,0,0,.Lscope6-.LFBB6
 479               		.stabd	78,0,0
 480               		.stabs	"uart_available:F(0,1)",36,0,572,uart_available
 481               	.global	uart_available
 482               		.type	uart_available, @function
 483               	uart_available:
 484               		.stabd	46,0,0
 532:uart.c        **** 
 533:uart.c        **** #if 0
 534:uart.c        **** /*************************************************************************
 535:uart.c        **** Function: uart_puts()
 536:uart.c        **** Purpose:  transmit string to UART
 537:uart.c        **** Input:    string to be transmitted
 538:uart.c        **** Returns:  none          
 539:uart.c        **** **************************************************************************/
 540:uart.c        **** void uart_puts(const char *s )
GAS LISTING /tmp/ccVHCL1a.s 			page 19


 541:uart.c        **** {
 542:uart.c        ****     while (*s) 
 543:uart.c        ****       uart_putc(*s++);
 544:uart.c        **** 
 545:uart.c        **** }/* uart_puts */
 546:uart.c        **** 
 547:uart.c        **** /*************************************************************************
 548:uart.c        **** Function: uart_puts_p()
 549:uart.c        **** Purpose:  transmit string from program memory to UART
 550:uart.c        **** Input:    program memory string to be transmitted
 551:uart.c        **** Returns:  none
 552:uart.c        **** **************************************************************************/
 553:uart.c        **** void uart_puts_p(const char *progmem_s )
 554:uart.c        **** {
 555:uart.c        ****     register char c;
 556:uart.c        ****     
 557:uart.c        ****     while ( (c = pgm_read_byte(progmem_s++)) ) 
 558:uart.c        ****       uart_putc(c);
 559:uart.c        **** 
 560:uart.c        **** }/* uart_puts_p */
 561:uart.c        **** #endif
 562:uart.c        **** 
 563:uart.c        **** 
 564:uart.c        **** /*************************************************************************
 565:uart.c        **** Function: uart_available()
 566:uart.c        **** Purpose:  Determine the number of bytes waiting in the receive buffer
 567:uart.c        **** Input:    None
 568:uart.c        **** Returns:  Integer number of bytes in the receive buffer
 569:uart.c        **** **************************************************************************/
 570:uart.c        **** int uart_available(void)
 571:uart.c        **** {
 485               		.stabn	68,0,572,.LM53-.LFBB7
 486               	.LM53:
 487               	.LFBB7:
 488               	/* prologue: function */
 489               	/* frame size = 0 */
 572:uart.c        ****         return (UART_RX_BUFFER_MASK + UART_RxHead - UART_RxTail) % UART_RX_BUFFER_MASK;
 490               		.stabn	68,0,573,.LM54-.LFBB7
 491               	.LM54:
 492 0192 8091 0000 		lds r24,UART_RxHead
 493 0196 2091 0000 		lds r18,UART_RxTail
 494 019a 90E0      		ldi r25,lo8(0)
 495 019c 0F96      		adiw r24,15
 496 019e 821B      		sub r24,r18
 497 01a0 9109      		sbc r25,__zero_reg__
 498 01a2 6FE0      		ldi r22,lo8(15)
 499 01a4 70E0      		ldi r23,hi8(15)
 500 01a6 0E94 0000 		call __divmodhi4
 501               	/* epilogue start */
 573:uart.c        **** }/* uart_available */
 502               		.stabn	68,0,574,.LM55-.LFBB7
 503               	.LM55:
 504 01aa 0895      		ret
 505               		.size	uart_available, .-uart_available
 506               	.Lscope7:
 507               		.stabs	"",36,0,0,.Lscope7-.LFBB7
 508               		.stabd	78,0,0
GAS LISTING /tmp/ccVHCL1a.s 			page 20


 509               		.stabs	"uart_flush:F(0,15)",36,0,585,uart_flush
 510               	.global	uart_flush
 511               		.type	uart_flush, @function
 512               	uart_flush:
 513               		.stabd	46,0,0
 574:uart.c        **** 
 575:uart.c        **** 
 576:uart.c        **** 
 577:uart.c        **** /*************************************************************************
 578:uart.c        **** Function: uart_flush()
 579:uart.c        **** Purpose:  Flush bytes waiting the receive buffer.  Acutally ignores them.
 580:uart.c        **** Input:    None
 581:uart.c        **** Returns:  None
 582:uart.c        **** **************************************************************************/
 583:uart.c        **** void uart_flush(void)
 584:uart.c        **** {
 514               		.stabn	68,0,585,.LM56-.LFBB8
 515               	.LM56:
 516               	.LFBB8:
 517               	/* prologue: function */
 518               	/* frame size = 0 */
 585:uart.c        ****     UART_RxHead = UART_RxTail;
 519               		.stabn	68,0,586,.LM57-.LFBB8
 520               	.LM57:
 521 01ac 8091 0000 		lds r24,UART_RxTail
 522 01b0 8093 0000 		sts UART_RxHead,r24
 523 01b4 00C0      		rjmp .L27
 524               	.L28:
 586:uart.c        **** 
 587:uart.c        ****     // flush readed data from internal fifo
 588:uart.c        ****     while ((UART0_STATUS & (1<<RXC)))
 589:uart.c        ****     {
 590:uart.c        ****         UDR;
 525               		.stabn	68,0,591,.LM58-.LFBB8
 526               	.LM58:
 527 01b6 8CB1      		in r24,44-32
 528               	.L27:
 589:uart.c        ****     while ((UART0_STATUS & (1<<RXC)))
 529               		.stabn	68,0,589,.LM59-.LFBB8
 530               	.LM59:
 531 01b8 5F99      		sbic 43-32,7
 532 01ba 00C0      		rjmp .L28
 533               	/* epilogue start */
 591:uart.c        ****     }
 592:uart.c        **** 
 593:uart.c        **** }/* uart_flush */
 534               		.stabn	68,0,594,.LM60-.LFBB8
 535               	.LM60:
 536 01bc 0895      		ret
 537               		.size	uart_flush, .-uart_flush
 538               	.Lscope8:
 539               		.stabs	"",36,0,0,.Lscope8-.LFBB8
 540               		.stabd	78,0,0
 541               		.stabs	"uart_setFormat:F(0,15)",36,0,600,uart_setFormat
 542               		.stabs	"wordLength:P(4,2)",64,0,599,24
 543               		.stabs	"numStopBits:P(4,2)",64,0,599,22
 544               		.stabs	"parity:P(4,2)",64,0,599,20
GAS LISTING /tmp/ccVHCL1a.s 			page 21


 545               	.global	uart_setFormat
 546               		.type	uart_setFormat, @function
 547               	uart_setFormat:
 548               		.stabd	46,0,0
 594:uart.c        **** 
 595:uart.c        **** //--------------------------------------------------------------------------
 596:uart.c        **** // Set frame format
 597:uart.c        **** //--------------------------------------------------------------------------
 598:uart.c        **** void uart_setFormat(uint8_t wordLength, uint8_t numStopBits, uint8_t parity)
 599:uart.c        **** {
 549               		.stabn	68,0,600,.LM61-.LFBB9
 550               	.LM61:
 551               	.LFBB9:
 552               	/* prologue: function */
 553               	/* frame size = 0 */
 600:uart.c        ****     register unsigned char set = 0;
 601:uart.c        ****     
 602:uart.c        ****     // setup format according to given parameters
 603:uart.c        ****     switch (wordLength)
 554               		.stabn	68,0,604,.LM62-.LFBB9
 555               	.LM62:
 556 01be 8730      		cpi r24,lo8(7)
 557 01c0 01F0      		breq .L33
 558 01c2 8830      		cpi r24,lo8(8)
 559 01c4 01F0      		breq .L34
 560 01c6 8630      		cpi r24,lo8(6)
 561 01c8 01F4      		brne .L40
 562 01ca 00C0      		rjmp .L41
 563               	.L34:
 564 01cc 86E0      		ldi r24,lo8(6)
 565 01ce 00C0      		rjmp .L35
 566               	.L40:
 567 01d0 80E0      		ldi r24,lo8(0)
 568 01d2 00C0      		rjmp .L35
 569               	.L33:
 570 01d4 84E0      		ldi r24,lo8(4)
 571 01d6 00C0      		rjmp .L35
 572               	.L41:
 604:uart.c        ****     {
 605:uart.c        ****         case 8:
 606:uart.c        ****                 set |= (1 << UCSZ1) | (1 << UCSZ0);
 607:uart.c        ****                 break;
 608:uart.c        ****         case 7:
 609:uart.c        ****                 set |= (1 << UCSZ1);
 610:uart.c        ****                 break;
 573               		.stabn	68,0,611,.LM63-.LFBB9
 574               	.LM63:
 575 01d8 82E0      		ldi r24,lo8(2)
 576               	.L35:
 611:uart.c        ****         case 6:
 612:uart.c        ****                 set |= (1 << UCSZ0);
 613:uart.c        ****                 break;
 614:uart.c        ****         default:
 615:uart.c        ****             break;
 616:uart.c        ****     }
 617:uart.c        **** 
 618:uart.c        ****     if (numStopBits == 2)
GAS LISTING /tmp/ccVHCL1a.s 			page 22


 577               		.stabn	68,0,619,.LM64-.LFBB9
 578               	.LM64:
 579 01da 6230      		cpi r22,lo8(2)
 580 01dc 01F4      		brne .L36
 619:uart.c        ****         set |= (1 << USBS);
 581               		.stabn	68,0,620,.LM65-.LFBB9
 582               	.LM65:
 583 01de 8860      		ori r24,lo8(8)
 584               	.L36:
 620:uart.c        **** 
 621:uart.c        ****     if (parity == 1)
 585               		.stabn	68,0,622,.LM66-.LFBB9
 586               	.LM66:
 587 01e0 4130      		cpi r20,lo8(1)
 588 01e2 01F4      		brne .L37
 622:uart.c        ****         set |= (1 << UPM1);
 589               		.stabn	68,0,623,.LM67-.LFBB9
 590               	.LM67:
 591 01e4 8062      		ori r24,lo8(32)
 592 01e6 00C0      		rjmp .L38
 593               	.L37:
 623:uart.c        ****     else if (parity == 2)
 594               		.stabn	68,0,624,.LM68-.LFBB9
 595               	.LM68:
 596 01e8 4230      		cpi r20,lo8(2)
 597 01ea 01F4      		brne .L38
 624:uart.c        ****         set |= (1 << UPM1) | (1 << UPM0);
 598               		.stabn	68,0,625,.LM69-.LFBB9
 599               	.LM69:
 600 01ec 8063      		ori r24,lo8(48)
 601               	.L38:
 625:uart.c        **** 
 626:uart.c        **** 
 627:uart.c        ****     #ifdef URSEL
 628:uart.c        ****     UCSRC = (1<<URSEL) | set;
 602               		.stabn	68,0,629,.LM70-.LFBB9
 603               	.LM70:
 604 01ee 8068      		ori r24,lo8(-128)
 605 01f0 80BD      		out 64-32,r24
 606               	/* epilogue start */
 629:uart.c        ****     #else
 630:uart.c        ****     UCSRC = set;
 631:uart.c        ****     #endif
 632:uart.c        **** 
 633:uart.c        **** }
 607               		.stabn	68,0,634,.LM71-.LFBB9
 608               	.LM71:
 609 01f2 0895      		ret
 610               		.size	uart_setFormat, .-uart_setFormat
 611               		.stabs	"set:r(0,11)",64,0,601,24
 612               		.stabn	192,0,0,.LFBB9-.LFBB9
 613               		.stabn	224,0,0,.Lscope9-.LFBB9
 614               	.Lscope9:
 615               		.stabs	"",36,0,0,.Lscope9-.LFBB9
 616               		.stabd	78,0,0
 617               		.stabs	"uart_setTxRx:F(0,15)",36,0,640,uart_setTxRx
 618               		.stabs	"tx:P(0,11)",64,0,639,24
GAS LISTING /tmp/ccVHCL1a.s 			page 23


 619               		.stabs	"rx:P(0,11)",64,0,639,22
 620               	.global	uart_setTxRx
 621               		.type	uart_setTxRx, @function
 622               	uart_setTxRx:
 623               		.stabd	46,0,0
 634:uart.c        **** 
 635:uart.c        **** //--------------------------------------------------------------------------
 636:uart.c        **** // Set frame format
 637:uart.c        **** //--------------------------------------------------------------------------
 638:uart.c        **** void uart_setTxRx(unsigned char tx, unsigned char rx)
 639:uart.c        **** {
 624               		.stabn	68,0,640,.LM72-.LFBB10
 625               	.LM72:
 626               	.LFBB10:
 627               	/* prologue: function */
 628               	/* frame size = 0 */
 640:uart.c        ****     if (tx) 
 629               		.stabn	68,0,641,.LM73-.LFBB10
 630               	.LM73:
 631 01f4 8823      		tst r24
 632 01f6 01F0      		breq .L43
 641:uart.c        ****         UART0_CONTROL |= (1<<TXEN);
 633               		.stabn	68,0,642,.LM74-.LFBB10
 634               	.LM74:
 635 01f8 539A      		sbi 42-32,3
 636 01fa 00C0      		rjmp .L44
 637               	.L43:
 642:uart.c        ****     else
 643:uart.c        ****         UART0_CONTROL &= ~(1<<TXEN);
 638               		.stabn	68,0,644,.LM75-.LFBB10
 639               	.LM75:
 640 01fc 5398      		cbi 42-32,3
 641               	.L44:
 644:uart.c        **** 
 645:uart.c        ****     if (rx)
 642               		.stabn	68,0,646,.LM76-.LFBB10
 643               	.LM76:
 644 01fe 6623      		tst r22
 645 0200 01F0      		breq .L45
 646:uart.c        ****         UART0_CONTROL |= (1<<RXEN) | (1 << RXCIE);
 646               		.stabn	68,0,647,.LM77-.LFBB10
 647               	.LM77:
 648 0202 8AB1      		in r24,42-32
 649 0204 8069      		ori r24,lo8(-112)
 650 0206 00C0      		rjmp .L48
 651               	.L45:
 647:uart.c        ****     else
 648:uart.c        ****         UART0_CONTROL &= ~(1<<RXEN) & ~(1<<RXCIE);
 652               		.stabn	68,0,649,.LM78-.LFBB10
 653               	.LM78:
 654 0208 8AB1      		in r24,42-32
 655 020a 8F76      		andi r24,lo8(111)
 656               	.L48:
 657 020c 8AB9      		out 42-32,r24
 658 020e 0895      		ret
 659               		.size	uart_setTxRx, .-uart_setTxRx
 660               	.Lscope10:
GAS LISTING /tmp/ccVHCL1a.s 			page 24


 661               		.stabs	"",36,0,0,.Lscope10-.LFBB10
 662               		.stabd	78,0,0
 663               		.stabs	"uart_setReceiveCallback:F(0,15)",36,0,656,uart_setReceiveCallback
 664               		.stabs	"cbReceived:P(0,16)=*(0,17)=f(0,15)",64,0,655,24
 665               	.global	uart_setReceiveCallback
 666               		.type	uart_setReceiveCallback, @function
 667               	uart_setReceiveCallback:
 668               		.stabd	46,0,0
 649:uart.c        **** }
 650:uart.c        **** 
 651:uart.c        **** //--------------------------------------------------------------------------
 652:uart.c        **** // Set recevie
 653:uart.c        **** //--------------------------------------------------------------------------
 654:uart.c        **** void uart_setReceiveCallback(void (*cbReceived)(void))
 655:uart.c        **** {
 669               		.stabn	68,0,656,.LM79-.LFBB11
 670               	.LM79:
 671               	.LFBB11:
 672               	/* prologue: function */
 673               	/* frame size = 0 */
 656:uart.c        ****     UART_ReceivedCallback = cbReceived;
 674               		.stabn	68,0,657,.LM80-.LFBB11
 675               	.LM80:
 676 0210 9093 0000 		sts (UART_ReceivedCallback)+1,r25
 677 0214 8093 0000 		sts UART_ReceivedCallback,r24
 678               	/* epilogue start */
 657:uart.c        **** }
 679               		.stabn	68,0,658,.LM81-.LFBB11
 680               	.LM81:
 681 0218 0895      		ret
 682               		.size	uart_setReceiveCallback, .-uart_setReceiveCallback
 683               	.Lscope11:
 684               		.stabs	"",36,0,0,.Lscope11-.LFBB11
 685               		.stabd	78,0,0
 686               		.stabs	"uart_setTransmitDoneCallback:F(0,15)",36,0,664,uart_setTransmitDoneCallback
 687               		.stabs	"cbTransmitted:P(0,16)",64,0,663,24
 688               	.global	uart_setTransmitDoneCallback
 689               		.type	uart_setTransmitDoneCallback, @function
 690               	uart_setTransmitDoneCallback:
 691               		.stabd	46,0,0
 658:uart.c        **** 
 659:uart.c        **** //--------------------------------------------------------------------------
 660:uart.c        **** // Set transmission callback
 661:uart.c        **** //--------------------------------------------------------------------------
 662:uart.c        **** void uart_setTransmitDoneCallback(void (*cbTransmitted)(void))
 663:uart.c        **** {
 692               		.stabn	68,0,664,.LM82-.LFBB12
 693               	.LM82:
 694               	.LFBB12:
 695               	/* prologue: function */
 696               	/* frame size = 0 */
 664:uart.c        ****     UART_TransmittedCallback = cbTransmitted;
 697               		.stabn	68,0,665,.LM83-.LFBB12
 698               	.LM83:
 699 021a 9093 0000 		sts (UART_TransmittedCallback)+1,r25
 700 021e 8093 0000 		sts UART_TransmittedCallback,r24
 701               	/* epilogue start */
GAS LISTING /tmp/ccVHCL1a.s 			page 25


 665:uart.c        **** }
 702               		.stabn	68,0,666,.LM84-.LFBB12
 703               	.LM84:
 704 0222 0895      		ret
 705               		.size	uart_setTransmitDoneCallback, .-uart_setTransmitDoneCallback
 706               	.Lscope12:
 707               		.stabs	"",36,0,0,.Lscope12-.LFBB12
 708               		.stabd	78,0,0
 709               		.stabs	"uart_clearTransmissionBuffer:F(0,15)",36,0,672,uart_clearTransmissionBuffer
 710               	.global	uart_clearTransmissionBuffer
 711               		.type	uart_clearTransmissionBuffer, @function
 712               	uart_clearTransmissionBuffer:
 713               		.stabd	46,0,0
 666:uart.c        **** 
 667:uart.c        **** //--------------------------------------------------------------------------
 668:uart.c        **** // Clear transmit buffer
 669:uart.c        **** //--------------------------------------------------------------------------
 670:uart.c        **** void uart_clearTransmissionBuffer(void)
 671:uart.c        **** {
 714               		.stabn	68,0,672,.LM85-.LFBB13
 715               	.LM85:
 716               	.LFBB13:
 717               	/* prologue: function */
 718               	/* frame size = 0 */
 672:uart.c        ****     UART_TxHead = UART_TxTail;
 719               		.stabn	68,0,673,.LM86-.LFBB13
 720               	.LM86:
 721 0224 8091 0000 		lds r24,UART_TxTail
 722 0228 8093 0000 		sts UART_TxHead,r24
 673:uart.c        ****     UART0_CONTROL &= ~_BV(UART0_UDRIE);
 723               		.stabn	68,0,674,.LM87-.LFBB13
 724               	.LM87:
 725 022c 5598      		cbi 42-32,5
 726               	/* epilogue start */
 674:uart.c        **** }
 727               		.stabn	68,0,675,.LM88-.LFBB13
 728               	.LM88:
 729 022e 0895      		ret
 730               		.size	uart_clearTransmissionBuffer, .-uart_clearTransmissionBuffer
 731               	.Lscope13:
 732               		.stabs	"",36,0,0,.Lscope13-.LFBB13
 733               		.stabd	78,0,0
 734               		.lcomm UART_TxBuf,256
 735               		.lcomm UART_RxBuf,16
 736               		.lcomm UART_TxHead,1
 737               		.lcomm UART_TxTail,1
 738               		.lcomm UART_RxHead,1
 739               		.lcomm UART_RxTail,1
 740               		.lcomm UART_LastRxError,1
 741               		.lcomm UART_TransmittedCallback,2
 742               		.lcomm UART_ReceivedCallback,2
 743               		.stabs	"UART_TxBuf:S(0,18)=ar(0,19)=r(0,19);0;0177777;;0;255;(0,20)=B(0,11)",40,0,299,UART_TxBuf
 744               		.stabs	"UART_RxBuf:S(0,21)=ar(0,19);0;15;(0,20)",40,0,300,UART_RxBuf
 745               		.stabs	"UART_TxHead:S(0,20)",40,0,301,UART_TxHead
 746               		.stabs	"UART_TxTail:S(0,20)",40,0,302,UART_TxTail
 747               		.stabs	"UART_RxHead:S(0,20)",40,0,303,UART_RxHead
 748               		.stabs	"UART_RxTail:S(0,20)",40,0,304,UART_RxTail
GAS LISTING /tmp/ccVHCL1a.s 			page 26


 749               		.stabs	"UART_LastRxError:S(0,20)",40,0,305,UART_LastRxError
 750               		.stabs	"UART_TransmittedCallback:S(0,16)",40,0,306,UART_TransmittedCallback
 751               		.stabs	"UART_ReceivedCallback:S(0,16)",40,0,307,UART_ReceivedCallback
 752               		.stabs	"",100,0,0,.Letext0
 753               	.Letext0:
GAS LISTING /tmp/ccVHCL1a.s 			page 27


DEFINED SYMBOLS
                            *ABS*:00000000 uart.c
     /tmp/ccVHCL1a.s:2      *ABS*:0000003f __SREG__
     /tmp/ccVHCL1a.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccVHCL1a.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccVHCL1a.s:5      *ABS*:00000034 __CCP__
     /tmp/ccVHCL1a.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccVHCL1a.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccVHCL1a.s:98     .text:00000000 __vector_13
     /tmp/ccVHCL1a.s:737    .bss:00000112 UART_RxHead
     /tmp/ccVHCL1a.s:738    .bss:00000113 UART_RxTail
     /tmp/ccVHCL1a.s:734    .bss:00000100 UART_RxBuf
     /tmp/ccVHCL1a.s:739    .bss:00000114 UART_LastRxError
     /tmp/ccVHCL1a.s:741    .bss:00000117 UART_ReceivedCallback
     /tmp/ccVHCL1a.s:201    .text:0000007e __vector_14
     /tmp/ccVHCL1a.s:735    .bss:00000110 UART_TxHead
     /tmp/ccVHCL1a.s:736    .bss:00000111 UART_TxTail
                             .bss:00000000 UART_TxBuf
     /tmp/ccVHCL1a.s:740    .bss:00000115 UART_TransmittedCallback
     /tmp/ccVHCL1a.s:291    .text:000000f4 uart_init
     /tmp/ccVHCL1a.s:356    .text:0000012e uart_getc
     /tmp/ccVHCL1a.s:415    .text:00000168 uart_putc
     /tmp/ccVHCL1a.s:462    .text:0000018e uart_startTransmission
     /tmp/ccVHCL1a.s:483    .text:00000192 uart_available
     /tmp/ccVHCL1a.s:512    .text:000001ac uart_flush
     /tmp/ccVHCL1a.s:547    .text:000001be uart_setFormat
     /tmp/ccVHCL1a.s:622    .text:000001f4 uart_setTxRx
     /tmp/ccVHCL1a.s:667    .text:00000210 uart_setReceiveCallback
     /tmp/ccVHCL1a.s:690    .text:0000021a uart_setTransmitDoneCallback
     /tmp/ccVHCL1a.s:712    .text:00000224 uart_clearTransmissionBuffer

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__divmodhi4
